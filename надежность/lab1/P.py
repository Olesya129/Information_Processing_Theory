import numpy as np
import matplotlib.pyplot as plt

# Параметры распределения Парето
alpha = 2.1  # Параметр формы, определяет "тяжесть" хвоста распределения
t0 = 5  # Минимальное значение времени, нижняя граница распределения


# Метод трапеций для численного интегрирования
def trapezoid_integrate(f, a, b, n=1000):
    """Вычисляет интеграл функции f от a до b методом трапеций с n интервалами.

    Аргументы:
        f (callable): Функция для интегрирования
        a (float): Нижний предел интегрирования
        b (float): Верхний предел интегрирования
        n (int): Количество интервалов (по умолчанию 1000)
    Возвращает:
        float: Приближенное значение интеграла
    """
    if a >= b:  # Если нижний предел больше или равен верхнему, интеграл равен 0
        return 0
    h = (b - a) / n  # Шаг интегрирования (ширина каждого интервала)
    x = np.linspace(a, b, n + 1)  # Создаём массив точек от a до b, включая границы
    y = np.array([f(xi) for xi in x])  # Вычисляем значения функции f в каждой точке x
    return (h / 2) * (
                y[0] + 2 * np.sum(y[1:-1]) + y[-1])  # Формула трапеций: h/2 * (первый + 2*сумма_середин + последний)


# Плотность распределения Парето
def pareto_pdf(t, alpha, t0):
    """Плотность распределения f(t) = (alpha / t0) * (t0 / t)^(alpha + 1) для t >= t0.

    Аргументы:
        t (float): Время, для которого вычисляется плотность
        alpha (float): Параметр формы
        t0 (float): Минимальное время
    Возвращает:
        float: Значение плотности или 0, если t < t0
    """
    return (alpha / t0) * (t0 / t) ** (alpha + 1) if t >= t0 else 0  # Плотность Парето или 0 для t < t0


# Проверка нормализации: ∫_{t0}^∞ f(t) dt ≈ 1
def check_normalization(alpha, t0, t_max=1000, n=10000):
    """Численно проверяет, что интеграл плотности от t0 до t_max равен ~1.

    Аргументы:
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        t_max (float): Верхний предел интегрирования (по умолчанию 1000)
        n (int): Количество интервалов (по умолчанию 10000)
    Возвращает:
        float: Значение интеграла
    """
    return trapezoid_integrate(lambda t: pareto_pdf(t, alpha, t0), t0, t_max,n)  # Интегрируем плотность методом трапеций


# Функция распределения: F(t) = ∫_{t0}^t f(u) du
def pareto_cdf(t, alpha, t0, n=1000):
    """Численное вычисление функции распределения (CDF) через интеграл плотности.

    Аргументы:
        t (float): Время, для которого вычисляется CDF
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        n (int): Количество интервалов для интегрирования
    Возвращает:
        float: Значение F(t) в диапазоне [0, 1]
    """
    if t < t0:  # Если t < t0, вероятность отказа равна 0
        return 0
    return trapezoid_integrate(lambda u: pareto_pdf(u, alpha, t0), t0, t, n)  # Интегрируем f(u) от t0 до t


# Вероятность безотказной работы: P(t) = 1 - F(t)
def pareto_sf(t, alpha, t0, n=1000):
    """Численное вычисление вероятности безотказной работы P(t).

    Аргументы:
        t (float): Время, для которого вычисляется P(t)
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        n (int): Количество интервалов для интегрирования
    Возвращает:
        float: Значение P(t) в диапазоне [0, 1]
    """
    return 1 - pareto_cdf(t, alpha, t0, n)  # P(t) = 1 - F(t), где F(t) вычислено численно


# Интенсивность отказов: λ(t) = f(t) / P(t)
def pareto_hazard(t, alpha, t0, n=1000):
    """Численное вычисление интенсивности отказов λ(t).

    Аргументы:
        t (float): Время, для которого вычисляется λ(t)
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        n (int): Количество интервалов для интегрирования
    Возвращает:
        float: Значение λ(t) или np.nan, если P(t) = 0
    """
    pdf = pareto_pdf(t, alpha, t0)  # Вычисляем плотность f(t)
    sf = pareto_sf(t, alpha, t0, n)  # Вычисляем P(t) численно
    return pdf / sf if sf > 0 else np.nan  # Делим f(t) на P(t), если P(t) > 0, иначе np.nan


# Средняя наработка: E[T] = ∫_{t0}^∞ t f(t) dt
def pareto_mean(alpha, t0, t_max=1000, n=10000):
    """Численное вычисление среднего времени до отказа E[T].

    Аргументы:
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        t_max (float): Верхний предел интегрирования
        n (int): Количество интервалов
    Возвращает:
        float: Значение E[T]
    """
    return trapezoid_integrate(lambda t: t * pareto_pdf(t, alpha, t0), t0, t_max, n)  # Интегрируем t * f(t)


# Дисперсия: Var[T] = E[T²] - E[T]²
def pareto_var(alpha, t0, t_max=1000, n=10000):
    """Численное вычисление дисперсии времени до отказа.

    Аргументы:
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        t_max (float): Верхний предел интегрирования
        n (int): Количество интервалов
    Возвращает:
        float: Значение дисперсии
    """
    mean = pareto_mean(alpha, t0, t_max, n)  # Вычисляем среднее E[T]
    second_moment = trapezoid_integrate(lambda t: t ** 2 * pareto_pdf(t, alpha, t0), t0, t_max, n)  # Вычисляем E[T²]
    return second_moment - mean ** 2  # Дисперсия = E[T²] - E[T]²


# Гамма-процентная наработка: решаем P(Tγ) = γ/100 методом бисекции
def pareto_ppf(gamma, alpha, t0, n=1000, tol=1e-6, max_iter=1000):
    """Численное нахождение Tγ, при котором P(Tγ) = γ/100.

    Аргументы:
        gamma (float): Процент вероятности (0 ≤ γ ≤ 100)
        alpha (float): Параметр формы
        t0 (float): Минимальное время
        n (int): Количество интервалов для интегрирования
        tol (float): Точность решения
        max_iter (int): Максимальное число итераций
    Возвращает:
        float: Значение Tγ или np.inf для γ = 100
    """
    if gamma >= 100:  # Если γ = 100, Tγ бесконечно
        return np.inf
    if gamma <= 0:  # Если γ = 0, Tγ равно t0
        return t0
    target = gamma / 100  # Целевое значение P(t) = γ/100
    t_left = t0  # Левая граница поиска
    t_right = t0 * 100  # Правая граница (большое значение, где P(t) ≈ 0)
    for _ in range(max_iter):  # Итерации метода бисекции
        t_mid = (t_left + t_right) / 2  # Середина интервала
        p_mid = pareto_sf(t_mid, alpha, t0, n)  # Значение P(t) в середине
        if abs(p_mid - target) < tol:  # Если достаточно близко к цели, возвращаем результат
            return t_mid
        if p_mid > target:  # Если P(t_mid) больше цели, ищем в правой половине
            t_left = t_mid
        else:  # Если P(t_mid) меньше цели, ищем в левой половине
            t_right = t_mid
    return t_mid  # Возвращаем последнее приближение


# Точка для вычислений
t_example = 10  # Время, для которого вычисляем характеристики (например, P(t), λ(t), f(t))

# Вычисления
pdf_example = pareto_pdf(t_example, alpha, t0)  # Плотность в точке t = 10
sf_example = pareto_sf(t_example, alpha, t0)  # Вероятность безотказной работы в t = 10
hazard_example = pareto_hazard(t_example, alpha, t0)  # Интенсивность отказов в t = 10
mean = pareto_mean(alpha, t0)  # Среднее время до отказа
var = pareto_var(alpha, t0)  # Дисперсия времени до отказа
std = np.sqrt(var) if var > 0 else np.inf  # Среднеквадратическое отклонение, если дисперсия конечна

# Таблица гамма-процентной наработки
gamma_percentages = np.arange(0, 101, 10)  # Массив процентов γ: 0%, 10%, ..., 100%
T_gamma_values = [pareto_ppf(g, alpha, t0) for g in gamma_percentages]  # Tγ для каждого γ

# Вывод результатов
print(f"1. Вероятность безотказной работы P({t_example}) = {sf_example:.6f}")  # P(t) с 6 знаками
print(f"2. Средняя наработка до отказа = {mean:.2f}")  # Среднее с 2 знаками
print(f"3. Дисперсия = {var:.2f}" if var > 0 else "3. Дисперсия = ∞")  # Дисперсия или ∞
print(f"   Среднеквадратическое отклонение = {std:.2f}" if var > 0 else "   СКО = ∞")  # СКО или ∞
print(f"4. Интенсивность отказов λ({t_example}) = {hazard_example:.6f}")  # λ(t) с 6 знаками
print(f"5. Плотность распределения f({t_example}) = {pdf_example:.6f}")  # f(t) с 6 знаками

print("\n6. Гамма-процентная наработка:")  # Заголовок таблицы
print("+--------+--------------+")  # Верхняя граница таблицы
print("| γ, %   | T_gamma      |")  # Заголовки столбцов
print("+--------+--------------+")  # Разделитель
for g, tg in zip(gamma_percentages, T_gamma_values):  # Проходим по γ и Tγ
    print(f"| {g:6} | {tg:12.2f} |" if g != 100 else f"| {g:6} | {'∞':12} |")  # Форматируем строку таблицы
print("+--------+--------------+")  # Нижняя граница таблицы
print("=" * 60)  # Разделитель для читаемости

# Проверка нормализации
norm_integral = check_normalization(alpha, t0)  # Интеграл плотности от t0 до t_max

# Графики
epsilon = 0.01  # Небольшое смещение от t0 для избежания численных артефактов
t_values = np.linspace(t0 + epsilon, t0 + 50, 1000)  # Массив времени от t0+ε до t0+50 для графиков

fig, axs = plt.subplots(2, 2, figsize=(14, 10))  # Создаём сетку 2x2 графиков размером 14x10 дюймов

# Плотность распределения
axs[0, 0].plot(t_values, [pareto_pdf(t, alpha, t0) for t in t_values], 'b')  # Рисуем f(t) синим
axs[0, 0].set_title('5. Плотность распределения f(t)')  # Заголовок графика
axs[0, 0].set_xlabel('Время t')  # Подпись оси X
axs[0, 0].set_ylabel('f(t)')  # Подпись оси Y
axs[0, 0].grid(True)  # Включаем сетку

# Вероятность безотказной работы
axs[0, 1].plot(t_values, [pareto_sf(t, alpha, t0) for t in t_values], 'g')  # Рисуем P(t) зелёным
axs[0, 1].set_title('1. Вероятность безотказной работы P(t)')  # Заголовок графика
axs[0, 1].set_xlabel('Время t')  # Подпись оси X
axs[0, 1].set_ylabel('P(t)')  # Подпись оси Y
axs[0, 1].grid(True)  # Включаем сетку

# Процентная вероятность
gamma_values = [100 * pareto_sf(t, alpha, t0) for t in t_values]  # γ(t) = 100 * P(t)
axs[1, 0].plot(t_values, gamma_values, 'k-')  # Рисуем γ(t) чёрным
axs[1, 0].set_title('6. Процентная вероятность безотказной работы γ(t)')  # Заголовок графика
axs[1, 0].set_xlabel('Время t')  # Подпись оси X
axs[1, 0].set_ylabel('γ, %')  # Подпись оси Y
axs[1, 0].grid(True)  # Включаем сетку

# Интенсивность отказов
axs[1, 1].plot(t_values, [pareto_hazard(t, alpha, t0) for t in t_values], 'r')  # Рисуем λ(t) красным
axs[1, 1].set_title('4. Интенсивность отказов λ(t)')  # Заголовок графика
axs[1, 1].set_xlabel('Время t')  # Подпись оси X
axs[1, 1].set_ylabel('λ(t)')  # Подпись оси Y
axs[1, 1].grid(True)  # Включаем сетку

plt.tight_layout()  # Автоматически регулирует расстояние между графиками для читаемости
plt.show()  # Отображает окно с графиками